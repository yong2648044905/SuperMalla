<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
        创建构造函数

    构造函数和普通的函数调用的方式不同
    普通函数就是直接调用，而构造函数需要使用new 关键字来调用
    构造函数的执行流程：
    创建新的对象->将新建的对象设置为函数中的this->逐行执行函数中的代码
    ->将新建对像作为返回值返回；
        */
        // function Person(vue, vuex) {
        //     this.name = vue,
        //         this.gg = vuex
        //     this.saNname = function () {
        //         alert("刘海涛傻逼")
        //     }
        // }

        // var a = new Person(10, "shgabiu");

        // var b = new Person(20, "shgabiu");
        // var c = new Person(30, "shgabiu");
        // console.log(a);
        // console.log(b);
        // console.log(a);


        ///简单点来说构造函数就是大写字母开头，new方法调用，用来区分函数

        //使用instanceof来检查一个对象是否是一个类的实例：
        //语法： 对象 instanceof 构造函数；
        //如果是返回true
        // console.log(a instanceof Person);


        //所有的对象都是object的后代
        // cconsole.log(a instanceof Object)


        function Person(name, age, gua) {
            this.name = name;
            this.age = age;
            this.gua = gua;
            this.sayName = fun;
        }
   
        //如果在构造函数中添加进去方法的话，就会使实例每调用一次创建一个方法。调用多少次就会执行多少次方法。这样很耗费内存。
        //解决方式：把方法定义到全局对象中，再赋值给函数的属性中这样不管调用了多少次都不会再去不断的创建方法。简单点来说就是让所有调用方式共用一个方法；
        //但是污染了全局作用域的命名空间
        function fun() {
            alert("shabi ")
        }
        //创建Person的实例
        var a = new Person(10, 15, 20);
        var b = new Person("shabuioshao")
        //调用Person函数里的sayname方法
        a.sayName();
        b.sayName();
    </script>
</head>

<body>

</body>

</html>